# zsh configuration: zprofile
# ============================================================================
# Load order: 2nd (sourced for LOGIN shells AND non-login command shells at SHLVL 1)
# Purpose: Set up session environment (PATH, language, one-time setup)
#
# When sourced:
#   - Login shells: Initial terminal window, SSH sessions, `zsh -l`
#   - Command shells: Non-login, non-interactive at SHLVL 1 (e.g., `zsh -c 'command'`)
#
# This runs BEFORE zshrc, so interactive features go in zshrc, not here.
#
# Startup sequence:
#   1. /etc/zshenv  (system-wide, always)
#   2. ~/.zshenv    (always; sets GLOBAL_RCS=off, blocking other /etc files)
#   3. ~/.zprofile  (if login shell OR non-login command shell at SHLVL 1) ‚Üê YOU ARE HERE
#   4. ~/.zshrc     (if interactive shell)

# Language
# ----------------------------------------------------------------------------
[[ -z "$LANG" ]] && eval "$(locale)"
[[ -z "$LANG" ]] && export LANG=en_US.UTF-8
[[ -z "$LC_ALL" ]] && export LC_ALL=$LANG

# Environment variables
# ----------------------------------------------------------------------------
export DOTFILES=${HOME%/}/.dotfiles

# Rule of thumb:
# - XDG_CONFIG_HOME: configuration files
# - XDG_DATA_HOME: user data files (databases, downloads, plugins, etc.)
# - XDG_STATE_HOME: non-disposable state files (history, logs, etc.)
# - XDG_CACHE_HOME: disposable cache files (temporary files,
#   performance-related, and data that can be recreated without loss)
export XDG_CONFIG_HOME=${HOME%/}/.config
export XDG_DATA_HOME=${HOME%/}/.local/share
export XDG_STATE_HOME=${HOME%/}/.local/state
export XDG_CACHE_HOME=${HOME%/}/.cache

export ZDATADIR=$XDG_DATA_HOME/zsh
export ZSTATEDIR=$XDG_STATE_HOME/zsh
export ZCACHEDIR=$XDG_CACHE_HOME/zsh

export ZPLUGDIR=$ZDATADIR/plugins
export ZFUNCDIR=$ZDATADIR/functions

[[ -d "$XDG_CACHE_HOME" ]] || mkdir -p "$XDG_CACHE_HOME"
[[ -d "$XDG_CONFIG_HOME" ]] || mkdir -p "$XDG_CONFIG_HOME"
[[ -d "$XDG_DATA_HOME" ]] || mkdir -p "$XDG_DATA_HOME"
[[ -d "$XDG_STATE_HOME" ]] || mkdir -p "$XDG_STATE_HOME"
[[ -d "$ZCACHEDIR" ]] || mkdir -p "$ZCACHEDIR"
[[ -d "$ZDATADIR" ]] || mkdir -p "$ZDATADIR"
[[ -d "$ZSTATEDIR" ]] || mkdir -p "$ZSTATEDIR"
[[ -d "$ZPLUGDIR" ]] || mkdir -p "$ZPLUGDIR"
[[ -d "$ZFUNCDIR" ]] || mkdir -p "$ZFUNCDIR"

if [[ -d "$TMPDIR" ]]; then
    export TMPPREFIX="${TMPDIR%/}/zsh"
    [[ -d "$TMPPREFIX" ]] || mkdir -p "$TMPPREFIX"
fi

hash -d config=$XDG_CONFIG_HOME
hash -d data=$XDG_DATA_HOME
hash -d state=$XDG_STATE_HOME
hash -d cache=$XDG_CACHE_HOME
hash -d zplugins=$ZPLUGDIR

# Homebrew
# --------------------------------------------------------------------------
# Use Bootsnap to speed up repeated brew calls
export HOMEBREW_BOOTSNAP=1

if [[ -d /home/linuxbrew/.linuxbrew ]]; then
    export HOMEBREW_BASE=/home/linuxbrew/.linuxbrew
elif [[ -d $HOME/.linuxbrew ]]; then
    export HOMEBREW_BASE=$HOME/.linuxbrew
elif [[ -d /opt/homebrew ]]; then
    export HOMEBREW_BASE=/opt/homebrew
else
    export HOMEBREW_BASE=/usr/local
fi

hash -d brew=$HOMEBREW_BASE

export HOMEBREW_PYTHON_VERSION="3.13"

# Terminal
# --------------------------------------------------------------------------
if [[ -z $TERM_PROGRAM ]]; then
    if [[ -n $GNOME_TERMINAL_SCREEN ]]; then
        export TERM_PROGRAM=gnome-terminal
    elif [[ -n $KITTY_LISTEN_ON ]]; then
        export TERM_PROGRAM=kitty
    fi
fi

# Tmux
# --------------------------------------------------------------------------
export TMUX_DATA_HOME="$XDG_DATA_HOME/tmux"
export TMUX_STATE_HOME="$XDG_STATE_HOME/tmux"
export TMUX_PLUGIN_MANAGER_PATH="$TMUX_DATA_HOME/plugins"

# Rust
export CARGO_HOME="$XDG_DATA_HOME/cargo"
export RUSTUP_HOME="$XDG_DATA_HOME/rustup"

# General paths
# ----------------------------------------------------------------------------
typeset -gU path

# Path
# --------------------------------------------------------------------------
# On macOS, use the system path_helper to set the initial PATH
if [[ -x /usr/libexec/path_helper ]]; then
    eval "$(/usr/libexec/path_helper -s)"
fi

# This is similar to what site.py does to find user modules
typeset -U _python_user_path=()

if [[ -n "$PYTHONUSERBASE" ]]; then
    _python_user_path+=("$PYTHONUSERBASE/bin")
fi

if [[ "$OSTYPE" == darwin* ]]; then
    _python_user_path+=("$HOME/Library/Python/$HOMEBREW_PYTHON_VERSION/bin")
fi

# site.py also falls back to ~/.local/bin, but it's not added here since it's
# at the beginning of the path

path=(
    $HOME/.local/bin
    $HOME/bin
    $DOTFILES/bin

    # npm global packages (corepack will install here, too)
    ~data/npm/bin

    # PostgreSQL
    ~brew/opt/postgresql@15/bin(/N)

    # Rust
    $CARGO_HOME/bin
    ~brew/opt/rustup/bin(/N)

    # Python
    $_python_user_path

    # Put python before $HOMEBREW_BASE/bin since some of its programs, like pip,
    # will eventually be overridden with things in $HOMEBREW_BASE/bin
    # https://discourse.brew.sh/t/pip-install-upgrade-pip-breaks-pip-when-installed-with-homebrew/5338
    ~brew/opt/python@${HOMEBREW_PYTHON_VERSION}/{libexec/,}bin(/N)

    # coreutils and gnu-sed
    ~brew/opt/{coreutils,gnu-sed}/libexec/gnubin(/N)

    ~brew/{s,}bin
    /usr/local/{s,}bin
    $path

    # VMware
    /Applications/VMware\ Fusion.app/Contents/Library(/N)
)

unset _python_user_path

# MANPATH doesn't need to be set because man will use PATH
# to find manpages
unset manpath

# Added by OrbStack: command-line tools and integration
# This won't be added again if you remove it.
if [[ -f ~/.orbstack/shell/init.zsh ]]; then
    source ~/.orbstack/shell/init.zsh
fi
